#include "form8.h"

// Переменная ошибок.
char StrError = StrNotInit;

void InitStr(string1 *st, unsigned n)
{
    if (n == 0)
    {
        StrError = StrNotInit;
        return;
    }
    else
    {
        *st = (string1)malloc((n + 3) * sizeof(char)); // выделение памяти, +2 для длины строки
                                                       // и +1 для символа конца строки
        if (st == nullptr)
        {
            std::cout << "Error: Memory allocation error!" << std::endl;
            StrError = StrNotInit;
            return;
        }
        unsigned short *count = (unsigned short *)*st; // первые два байта - счетчик
        *count = n;                                    // запись максимальной длины строки
        (*st)[n + 3] = '\0';                           // запись символа конца строки
        StrError = StrEmpty;                           // установка флага ошибок в "пустая строка"
    }
}

void InputStr(string1 s)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    char c;                                      // вводимый символ
    while ((c = getchar()) != '\n' && n > 0)     // ввод строки до символа конца строки
                                                 // или до достижения максимальной длины строки
    {
        *p++ = c; // запись символа в строку
        n--;      // уменьшение счетчика
    }
    *p = '\0'; // запись символа конца строки}
    StrError = StrOk;
}

void OutputStr(string1 s)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    while (*p != '\0' && n > 0)                  // вывод строки до символа конца строки
                                                 // или до достижения максимальной длины строки
    {
        putchar(*p++); // вывод символа
        n--;           // уменьшение счетчика
    }
}

void WriteToStr(string1 st, char *s)
{
    unsigned short *count = (unsigned short *)st; // первые два байта - счетчик
    unsigned n = *count;                          // максимальная длина строки
    char *p = st + 2;                             // указатель на первый символ строки
    while (*s != '\0' && n > 0)                   // запись строки до символа конца строки
                                                  // или до достижения максимальной длины строки
    {
        *p++ = *s++; // запись символа в строку
        n--;         // уменьшение счетчика
    }
    *p = '\0'; // запись символа конца строки
    StrError = StrOk;
}

void WriteFromStr(char *s, string1 st)
{
    unsigned short *count = (unsigned short *)st; // первые два байта - счетчик
    unsigned n = *count;                          // максимальная длина строки
    char *p = st + 2;                             // указатель на первый символ строки
    while (*p != '\0' && n > 0)                   // запись строки до символа конца строки
                                                  // или до достижения максимальной длины строки
    {
        *s = *p++; // запись символа в строку
        *s++;
        n--; // уменьшение счетчика
    }
    *s = '\0'; // запись символа конца строки
}

int Comp(string1 s1, string1 s2)
{
    unsigned short *count = (unsigned short *)s1; // первые два байта - счетчик
    unsigned n = *count;                          // максимальная длина строки
    char *p1 = s1 + 2;                            // указатель на первый символ строки
    char *p2 = s2 + 2;                            // указатель на первый символ строки
    while (*p1 != '\0' && *p2 != '\0' && n > 0)   // сравнение строк до символа конца строки
                                                  // или до достижения максимальной длины строки
    {
        if (*p1 != *p2) // сравнение символов
        {
            if (*p1 > *p2)      // если символ в первой строке больше
                return 1;       // возвращаем 1
            else if (*p1 < *p2) // если символ во второй строке больше
                return -1;      // возвращаем -1
        }
        p1++; // переход к следующему символу
        p2++; // переход к следующему символу
        n--;  // уменьшение счетчика
    }
    if (*p1 == '\0' && *p2 == '\0') // если обе строки закончились
        return 0;                   // возвращаем 0
    else if (*p1 == '\0')           // если конец первой строки
        return -1;                  // возврат -1
    else if (*p2 == '\0')           // если конец второй строки
        return 1;                   // возврат 1
    return -2;
}

void Delete(string1 s, unsigned Index, unsigned Count)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    if (Index >= n)                              // если индекс выходит за пределы строки
        return;                                  // выход
    if (Index + Count > n)                       // если индекс + количество символов выходит за пределы строки
        Count = n - Index;                       // уменьшение количества символов
    p += Index;                                  // переход к индексу
    while (*p != '\0')                           // сдвиг строки
    {
        *p = *(p + Count); // запись символа в строку
        p++;               // переход к следующему символу
    }
}

void Insert(string1 Subs, string1 s, unsigned Index)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    if (Index >= n)                              // если индекс выходит за пределы строки
        return;                                  // выход
    p += Index;                                  // переход к индексу
    char *p2 = p;                                // указатель на символ строки
    while (*p2 != '\0')                          // поиск конца строки
        p2++;
    unsigned SubsLen = Length(Subs); // длина вставляемой строки
    while (p2 >= p)                  // сдвиг строки
    {
        *(p2 + SubsLen) = *p2; // запись символа в строку
        p2--;                  // переход к следующему символу
    }
    p2 = Subs + 2;      // указатель на первый символ строки
    while (*p2 != '\0') // запись строки Subs в строку s
    {
        *p = *p2; // запись символа в строку
        p++;      // переход к следующему символу
        p2++;     // переход к следующему символу
    }
}

void Concat(string1 s1, string1 s2, string1 srez)
{
    unsigned short *count = (unsigned short *)s1; // первые два байта - счетчик
    unsigned n = *count;                          // максимальная длина строки
    char *p1 = s1 + 2;                            // указатель на первый символ строки
    char *p2 = s2 + 2;                            // указатель на первый символ строки
    char *pRes = srez + 2;                        // указатель на первый символ строки
    while (*p1 != '\0' && n > 0)                  // копирование первой строки
    {
        *pRes = *p1; // запись символа в строку
        p1++;        // переход к следующему символу
        pRes++;      // переход к следующему символу
        n--;         // уменьшение счетчика
    }
    while (*p2 != '\0' && n > 0) // копирование второй строки
    {
        *pRes = *p2; // запись символа в строку
        p2++;        // переход к следующему символу
        pRes++;      // переход к следующему символу
        n--;         // уменьшение счетчика
    }
    *pRes = '\0'; // запись символа конца строки
    StrError = StrOk;
}

void Copy(string1 s, unsigned Index, unsigned Count, string1 Subs)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    char *pRes = Subs + 2;                       // указатель на первый символ строки
    if (Index >= n)                              // если индекс выходит за пределы строки
        return;                                  // выход
    if (Index + Count > n)                       // если индекс + количество выходит за пределы строки
        Count = n - Index;                       // уменьшение количества
    p += Index;                                  // переход к индексу
    for (int i = 0; i < Count; i++)              // копирование подстроки в строку
    {
        *pRes = *p; // запись символа в строку
        p++;        // переход к следующему символу
        pRes++;     // переход к следующему символу
    }
    *pRes = '\0'; // запись символа конца строки
    StrError = StrOk;
}

unsigned Length(string1 s)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    unsigned i = 0;                              // счетчик
    while (*p != '\0' && n > 0)                  // поиск символа конца строки
    {
        p++; // переход к следующему символу
        i++; // увеличение счетчика
        n--; // уменьшение счетчика
    }
    return i; // возврат длины строки
}

// find first occurrence of substring in string
unsigned Pos(string1 SubS, string1 s)
{
    unsigned short *count = (unsigned short *)s; // первые два байта - счетчик
    unsigned n = *count;                         // максимальная длина строки
    char *p = s + 2;                             // указатель на первый символ строки
    char *pSub = SubS + 2;                       // указатель на первый символ строки
    unsigned i = 0;                              // счетчик
    while (*p != '\0' && n > 0)                  // поиск символа конца строки
    {
        if (*p == *pSub) // если символы равны
        {
            char *p1 = p;                                                   // указатель на первый символ строки
            char *pSub1 = pSub;                                             // указатель на первый символ строки
            while (*p1 == *pSub1 && *p1 != '\0' && *pSub1 != '\0' && n > 0) // поиск символа конца строки
            {
                p1++;    // переход к следующему символу
                pSub1++; // переход к следующему символу
                n--;     // уменьшение счетчика
            }
            if (*pSub1 == '\0') // если символы равны
            {
                return i; // возврат длины строки
            }
        }
        p++; // переход к следующему символу
        i++; // увеличение счетчика
        n--; // уменьшение счетчика
    }
    return -1;
}

void DoneStr(string1 s)
{
    free(s); // освобождение памяти
    StrError = StrNotInit;
}